- Map: '키-값' 의 쌍으로 나열되어 있어 키값을 통해 원하는 값을 한번에 찾아낼 수 있다.
 List :  순차적으로 데이터를 저장하거나 엑세스 할때 사용.

- maven
프로젝트에 필요한 라이브러리를 자동으로 관리해주는 빌드 도구이다. 필요한 라이브러리 jar파일을 자동으로 다운 받을 수 있다.

- static
선언된 함수내에서만 사용이 가능한 것.

- 상속
부모 클래스가 가지고있는 모든것을(생성자 제외) 자식클래스가 물려받아 같이 공유하며 나아가 확장(extends)하는 개념
단점 : 상위 클래스가 변경이 일어나면 하위 클래스도 따라서 변형되기 때문에 하위 클래스의 동작을 예측하기 힘들다.

- 세션과 쿠키의 차이점은 무엇인가?
- 세션: 일정 시간동안 같은 브라우저로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지하는 기술
- 쿠키: 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.

- 이벤트 버블링과 캡처링이란?
- 이벤트 버블링
: 특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 하위 요소에서 더 상위의 화면 요소들로 전달되어 가는 특성을 의미(아래 div->div->...->body 위)
-이벤트 캡쳐링
이벤트 버블링과 반대 방향인 상위요소에서 하위요소로 진행되는 이벤트 전파 방식
(addEventListener() - capture:true)

-event.target은 실제 이벤트가 시작된 ‘타깃’ 요소입니다. 버블링이 진행되어도 변하지 않습니다.(상단에 감싸고 있는 부분이 호출)
-this는 ‘현재’ 요소로, 현재 실행 중인 핸들러가 할당된 요소를 참조

*표준 DOM 이벤트에서 정의한 이벤트 흐름 3가지 단계
1. 캡처링 단계 – 이벤트가 하위 요소로 전파되는 단계->
2. 타깃 단계 – 이벤트가 실제 타깃 요소에 전달되는 단계@
3. 버블링 단계 – 이벤트가 상위 요소로 전파되는 단계<-


- Vector / List 관련된 차이점 및 시간 복잡도 관련 질문
vector, arraylist는 동적 배열이기때문에 아이템을 맨 마지막이나 중간에 삽입할 수 있고 객체 수가 많아지면 자동으로 크기가 조절됩니다.
차이점은 vector는 동기화가 되어있어 한번에 하나의 스레드만 접근 가능하여 안전하고
-arraylist는 동기화 되어있지 않아 성능이 vector보다 빠릅니다. 무작위 접근 가능
-linkedlist: 내부적으로 연결 리스트를 이용해서 요소를 저장한다, 순차접근만 가능하고 추가/삭제 연산이 빠르다

- 프로세스(process)란?
단순히 실행 중인 프로그램
- 스레드(thread)란?
프로세스 내에서 실제로 작업을 수행하는 주체
(사용 방법 : extends thread / implements Runnable)

- 정수 오버플로우로 인한 출력 결과 예측
정수형 변수의 오버플로우는 정수값이 증가하면서, 허용된 가장 큰 값보다 더 커져서 실제 저장되는 값은 아주 작은 수 이거나, 음수인 경우를 의미한다.
따라서 값이 음수인지 아닌지 검사하는 부분이 필요하다

- 인터페이스(implelents와 추상클래스(abstract)의 차이점
공통점 – 선언만 있고 구현 내용은 없다.
-추상 클래스(abstract class) : 단일 상속만 가능하며 상속을 받아 기능을 확장시키는 것이 목적이다.
-인터페이스(interface) : 다중 상속이 가능하고 모든 메서드들은 추상 메서드로 간주되기 때문에 abstract를 적지 않는다
구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 목적
![image](https://user-images.githubusercontent.com/72377237/125199486-58103000-e2a1-11eb-9a88-ae0bf4eab434.png)


- spring mvc 패턴
MVC란 ? 사용자가 controller(servlet,dao)를 조작하면 controller는 model(dto)을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View(html,jsp)를 제어해서 사용자에게 전달하는 것
Model: 데이터
View: 화면 출력 로직
Controller: Model과 View의 연결하는 제어 로직을 담당

@Controller : @RequestMapping을 통해서 메소드에 호출을 해주거나, 필요한 로직 @Service를 통해 호출하는등의 역할을 합니다.
@Service : 비즈니스 로직을 처리하는 곳(Service Interface -> ServiceImpl class)
@Repository : 실제로 커넥션을 통해 DB에 접근하는 객체
![image](https://user-images.githubusercontent.com/72377237/125199480-50e92200-e2a1-11eb-9e61-b75f21a86e69.png)

클라이언트가 URL로 정보를 요청하면 서블릿의 핵심 요소인 DispatcherServlet으로 이동 됩니다. 매핑한 컨트롤러가 있는지 검색하고 결과를 출력할 view 이름을 리턴합니다. 뷰 리졸버에서 리턴값을 처리하고 그 결과를 view로 보내서 클라이언트에게 최종 결과를 출력해줍니다.

- DBCP(DataBase Connection Pool) : DB와 커넥션을 맺고 있는 객체를 관리하는 역할 
-커넥션풀 : 웹 컨테이너가 실행되면서 DB와 미리 연결 해놓은 객체들을 pool에 저장해두었다가 클라이언트 요청이 오면 connection을 빌려주고, 처리가 끝나면 다시 connection을 반납받아 pool에 저장하는 방식
-웹 컨테이너 : 웹 서버의 컴포넌트 중 하나로 자바 서블릿과 상호받용한다.

- 큐와 스택의 차이
스택은 말 그대로 쌓는 구조여서 접근 방식은 LIFO의 구조입니다.
맨 위에 있는 스택을 top이라고 부르고 삽입하는 연산은 push, 삭제하는 연산은 pop이라고 합니다. 그리고 비어있는 스택에서 추출하려할 때 stack underflow라고 하며, 스택이 넘치는 경우 stack overflow라고 한다. (ex 웹 브라우저 뒤로가기)
큐는 하나의 통로를 생각하면 되는데 스택과 반대로 FIFO의 구조입니다.
삽입 연산은 인큐라고 부르며 이루어지는 곳은 리어입니다. 그리고 삭제 연산은 디큐로 이루어지는 곳은 프론트하고 하며 작업이 양쪽으로 이루어진다는 것을 알 수 있습니다.


- 객체지향 프로그래밍이란(OOP)
필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
*장점 : 코드 재사용 용이, 유지보수 쉬움
*단점 : 처리속도 상대적으로 느림, 설계시 많은 노력 필요


- 클래스와 인스턴스(객체)는 무엇인지 설명해주세요.
-클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것
-인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터
![image](https://user-images.githubusercontent.com/72377237/125199475-4c246e00-e2a1-11eb-8c2f-ec37a80e962f.png)


●객체 지향의 특징 : 캡슐화 / 추상화 / 상속성 / 다형성
*추상화 
: 객체에서 공통된 속성과 행위를 추출하는 것
*캡슐화
: 접근 제어자를 이용해서 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈(클래스)을 내부로 감추는 것이다.
(public > protected > default > private)
*상속?
부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.(다중상속은 불가하다.)
*다형성?
하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것이다.
즉 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기다.
*오버라이딩 : 부모클래스의 메서드와 같은 이름과 매개변수를 재정의 하는것.
*오버로딩 : 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것.


- getter, setter 를 사용하는 이유는 무엇인가요?
getter, setter를 사용하면 메서드를 통해서 접근하기 때문에, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있기 때문이다.

- 트랜잭션의 정의 
트랜잭션(Transaction)은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
-트랜잭션의 특징
1. 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
3. 하나의 트랜잭션은 Commit되거나 Rollback된다.
*트랜잭션의 성질 
-Atomicity(원자성)
1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
-Consistency(일관성)
1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.
-Isolation(독립성,격리성)
1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.
-Durablility(영속성,지속성)
1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.


- 커밋할경우에 대한 작업 단위
일관성이 유지되는 단위로 최대한 작게 쪼개서 되어야합니다.

- 자료구조/알고리즘
-자료구조의 사전적 의미
:데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계
*알고리즘의 사전적 의미
:문제를 해결하기 위한 것으로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합
ex)
자료구조를 도서관의 책장에 책을 꼽는 것으로 가정을 할 수 있다면 도서관에 존재하는 많은 책장은 모두 규칙적으로 책이 진열이 되어있습니다. 그 규칙은 도서관마다 다르며 다양한 방법이 존재합니다. 예를 들어 ABC 알파벳 순서, 연도 순서, 책을 세로로 또는 가로로 진열을 합니다. 이렇게 데이터가 저장되는 형태 즉 데이터 표현 및 저장 방식을 자료구조라고 의미할 수 있습니다.
반면에 알고리즘은 앞에 예시를 들었던 도서관에 책이 순서되로 모두 진열이 되었다면 그 책을 찾는 것에 비교할 수 있습니다. 자신이 원하는 책을 찾을 때 책장의 왼쪽, 오른쪽, 위쪽, 아래쪽으로 책을 찾을 수 있으며 큰 책, 작은 책으로도 검색이 가능하며 심지어 무작위로도 책을 찾을 수 있습니다. 이러한 것과 같이 저장된 데이터를 명령 처리 및 제어 방법을 알고리즘이라고 의미할 수 있습니다.

- 기본적인 자료구조
종류 : List(리스트), Linked List(링드 리스트), Array(배열), Stack(스택), Queue(큐), Dequeue(디큐), Tree(트리), Heap(힙), Graph(그래프)

- List와 Set의 차이점
: List에는 중복되게 들어갈 수 있지만 Set은 중복이 허용이 되지 않습니다


- java primitive type 데이터 타입 종류(자료형 – 기본형 <-> 참조형)
boolean(1)/ byte(1),short(2),int(4),long(8)/float(4),double(8)/char(2)

- 디자인 패턴
: 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들에 대한 해법.
인터페이스? 기능의 선언과 구현을 분리함. 접근 가능한 접근점 제공
델리게이트? 기능을 수행할 때 해당 객체 이외의 다른 객체의 기능을 사용할 때
전략패턴? 여러 가지 알고리즘을 하나의 접근점을 통해 구현하고 그 알고리즘을 변경 가능하도록 하는 것.


- 접근제한자 4가지 : 
i) public      : 모든 접근을 허용
ii) protected : 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용
iii) default    : 같은 패키지(폴더)에 있는 객체들만 허용
iv) private    : 현재 객체 내에서만 허용

- 자바(JDK) 1.3와 1.5 차이점
명칭이 JavaEE로 개칭되었고 어노테이션이랑, 제네릭<T> 등등이 도입되었습니다.

- Spring? : 자바 플랫폼을 위한 오픈소스 애플리케이션 프레임워크
*DI
: 객체를 주입하여 상호 간의 연결을 시도하는 것
*IOC
: 설정파일을 작성하면 스프링 주도하에 모든 작업이 발생하는 것
*AOP(관점지향프로그래밍)
: 사용자가 작성한 주업무 로직 이외에 개발자나 운영자의 관점으로 로직이 겉에 탈부착 가능하도록 추가하는 것.


- DBMS
다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구의 집합
*장점 : 구조적으로 저장돼서 중복성이 제어된다.
*유형의 관계 : 일대일, 일대다, 다대다

- RDBMS(관계형 데이터베이스 관리 시스템)
별도의 테이블에 저장된 관계형 데이터 모델을 기반으로하며 공통 열의 사용과 관련이 있다.

- SQL
DDL(데이터 정의 언어), DML(데이터 조작 언어), DCL(데이터 제어 언어)


- 정규화 : 테이블을 분할하여 데이터베이스에서 중복 데이터를 제거하는 프로세스
- 비정규화 : 성능을 향상시키기 위해 테이블에 중복 데이터를 추가하는 프로세스

- 데이터베이스 뷰? 허용된 데이터를 제한적으로 보여주기 위한 가상 테이블

- 기본키 : 고유하게 식별되는 테이블의 열
- 복합키 : 하나의 속성으로는 기본키가 될 수 없는 경우에 둘 이상의 컬럼을 묶어 식별자로 정의하는 키

- Rest
: HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미한다.
- API(Application Programming Interface)란
데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는 것
- REST API의 정의
REST 기반으로 서비스 API를 구현한 것
확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다

- 직렬화(Serialize)
자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술.

- Servlet – java코드 안에 html 코드 / JSP – html코드 안에 java코드
  
- OSI 7계층
  (7) 응용 / 표현 / 세션 / 전송 / 네트워크 / 데이터링크 / 물리 (1)
  
- HTTP(Hyper Text Tranfer Protocol)
  : 인터넷에서 데이터를 주고받을 수 있는 프로토콜
  : 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 요청(request)하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작
  
- HTTPS(http + secure socket)
  : 데이터를 주고 받는 과정에서 '보안' 요소가 추가된 것
  
- ArrayList와 LinkedList의 차이점
  : LinkedList는 데이터 삽입 삭제가 빠르나 자료를 검색할 때 순차탐색하기 때문에 탐색 시간이 오래 소요된다. ArrayList는 반대
  
  
